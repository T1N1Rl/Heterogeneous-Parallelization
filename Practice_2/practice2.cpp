#include <iostream>      
#include <vector>       
#include <chrono>       
#include <omp.h>      
#include <iomanip>       

using namespace std;                 // Используем стандартное пространство имён std
using namespace std::chrono;         // Используем пространство имён chrono для работы со временем


// Функция заполнения массива случайными числами
void fillRandom(vector<int>& arr, int size) {   // Функция принимает массив по ссылке и его размер
    arr.resize(size);                           // Устанавливаем размер массива

    for (int i = 0; i < size; i++)              // Цикл по всем элементам массива
        arr[i] = rand() % 10000;                // Заполняем массив случайными числами
}

// Пузырковая сортировка

// Последовательная версия пузырьковой сортировки
void bubbleSortSeq(vector<int>& arr) {           // Функция принимает массив для сортировки
    int n = arr.size();                          // Получаем размер массива

    for (int i = 0; i < n - 1; i++) {             // Внешний цикл — количество проходов
        for (int j = 0; j < n - i - 1; j++) {     // Внутренний цикл — сравнение элементов
            if (arr[j] > arr[j + 1])              // Если текущий элемент больше следующего
                swap(arr[j], arr[j + 1]);         // Меняем элементы местами
        }
    }
}

// Параллельная версия пузырьковой сортировки
void bubbleSortPar(vector<int>& arr) {            // Функция принимает массив для сортировки
    int n = arr.size();                           // Получаем размер массива

    for (int i = 0; i < n - 1; i++) {              // Внешний цикл остаётся последовательным

        #pragma omp parallel for                  // Директива OpenMP для распараллеливания цикла
        for (int j = 0; j < n - i - 1; j++) {      // Внутренний цикл выполняется параллельно
            if (arr[j] > arr[j + 1])               // Проверяем соседние элементы
                swap(arr[j], arr[j + 1]);          // Меняем элементы местами
        }
    }
}

// Сортировка выборкой

// Последовательная версия сортировки выбором
void selectionSortSeq(vector<int>& arr) {         // Функция принимает массив для сортировки
    int n = arr.size();                           // Получаем размер массива

    for (int i = 0; i < n - 1; i++) {              // Проходим по всем элементам массива
        int min_idx = i;                          // Индекс минимального элемента

        for (int j = i + 1; j < n; j++) {          // Ищем минимальный элемент в неотсортированной части
            if (arr[j] < arr[min_idx])             // Если найден элемент меньше текущего минимума
                min_idx = j;                      // Обновляем индекс минимума
        }

        swap(arr[i], arr[min_idx]);               // Меняем текущий элемент с минимальным
    }
}

// Параллельная версия сортировки выбором
void selectionSortPar(vector<int>& arr) {         // Функция принимает массив для сортировки
    int n = arr.size();                           // Получаем размер массива

    for (int i = 0; i < n - 1; i++) {              // Последовательный внешний цикл
        int min_idx = i;                          // Начальный индекс минимума

        #pragma omp parallel for                  // Параллельный поиск минимума
        for (int j = i + 1; j < n; j++) {          // Цикл выполняется в нескольких потоках
            if (arr[j] < arr[min_idx])             // Сравнение элементов
                min_idx = j;                      // Возможна гонка данных (учебный пример)
        }

        swap(arr[i], arr[min_idx]);               // Перестановка элементов
    }
}


// Сортировка вставкой

// Последовательная версия сортировки вставкой
void insertionSortSeq(vector<int>& arr) {         // Функция принимает массив для сортировки
    int n = arr.size();                           // Получаем размер массива

    for (int i = 1; i < n; i++) {                  // Начинаем со второго элемента массива
        int key = arr[i];                         // Сохраняем текущий элемент
        int j = i - 1;                            // Индекс предыдущего элемента

        while (j >= 0 && arr[j] > key) {           // Сдвигаем элементы, пока не найдём место
            arr[j + 1] = arr[j];                  // Сдвиг элемента вправо
            j--;                                  // Переход к следующему элементу
        }

        arr[j + 1] = key;                         // Вставляем элемент на нужную позицию
    }
}

// Параллельная версия сортировки вставкой (без ускорения)
void insertionSortPar(vector<int>& arr) {         // Функция принимает массив для сортировки
    insertionSortSeq(arr);                        // Вызываем последовательную версию
}


// Функция тестирование производительности
void benchmark(int size) {                        // Функция принимает размер массива
    cout << "\nArray size: " << size << endl;     // Выводим размер тестируемого массива

    vector<int> original, data;                   // Объявляем массивы
    fillRandom(original, size);                   // Заполняем исходный массив случайными числами

    // Лямбда-функция для измерения времени сортировки
    auto test = [&](string name, void (*sortFunc)(vector<int>&)) {

        data = original;                          // Копируем исходный массив
        auto start = high_resolution_clock::now(); // Фиксируем время начала
        sortFunc(data);                           // Запускаем сортировку
        auto end = high_resolution_clock::now();   // Фиксируем время окончания

        double time = duration<double>(end - start).count(); // Вычисляем время выполнения

        cout << left << setw(20) << name           // Выводим название алгоритма
             << ": "                               // Разделитель
             << fixed << setprecision(5)           // Форматируем число
             << time << " sec" << endl;            // Выводим время
    };

    test("Bubble Seq", bubbleSortSeq);             // Тест пузырьковой сортировки (последовательно)
    test("Bubble Par", bubbleSortPar);             // Тест пузырьковой сортировки (параллельно)
    test("Selection Seq", selectionSortSeq);       // Тест сортировки выбором (последовательно)
    test("Selection Par", selectionSortPar);       // Тест сортировки выбором (параллельно)
    test("Insertion Seq", insertionSortSeq);       // Тест сортировки вставкой (последовательно)
    test("Insertion Par", insertionSortPar);       // Тест сортировки вставкой (параллельно)
}

// Главная функция
int main() {                                      // Точка входа в программу
    srand(time(0));                               // Инициализация генератора случайных чисел

    #ifdef _OPENMP                                // Проверка поддержки OpenMP
        cout << "OpenMP enabled. Threads: "       // Вывод сообщения
             << omp_get_max_threads() << endl;    // Вывод количества потоков
    #endif

    vector<int> sizes = {1000, 10000, 100000};             // Размеры массивов для тестирования

    for (int s : sizes)                           // Проходим по всем размерам
        benchmark(s);                             // Запускаем тестирование

    return 0;                                     // Завершаем программу
}
