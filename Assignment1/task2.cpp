#include <iostream>     
#include <vector>
#include <cstdlib>    
#include <ctime>       
#include <chrono>   

using namespace std;   

int main() {
    // Настройка параметров

    const int N = 1000000; // Размер массива

    // 2. Динамическое выделение памяти
    int* arr = new (nothrow) int[N]; // Выделяем память под массив в куче
                                      // "nothrow" предотвращает выброс исключения при нехватке памяти
    if (!arr) {                       // Проверяем, удалось ли выделить память
        cerr << "Memory allocation error" << endl; // Сообщение об ошибке
        return 1;                     // Завершаем программу с кодом ошибки
    }

    // Инициализация генератора случайных чисел

    srand(time(0));  // Используем текущее время как "зерно" генератора, чтобы числа были разными каждый запуск

    // Заполнение массива случайными числами

    for (int i = 0; i < N; ++i) {    // Проходим по каждому элементу массива
        arr[i] = rand();              // Присваиваем случайное число (от 0 до RAND_MAX)
    }

    // Засекаем время начала поиска min и max

    auto start = chrono::high_resolution_clock::now(); // Запоминаем момент времени начала алгоритма

    // Инициализация min и max

    int min_val = arr[0];  // Берём первый элемент как начальное минимальное значение
    int max_val = arr[0];  // Берём первый элемент как начальное максимальное значение

    // Последовательный поиск min и max

    for (int i = 1; i < N; ++i) {       // Проходим по всем элементам массива начиная со второго
        if (arr[i] < min_val) min_val = arr[i];  // Если текущий элемент меньше текущего min → обновляем min
        if (arr[i] > max_val) max_val = arr[i];  // Если текущий элемент больше текущего max → обновляем max
    }

    // Засекаем время окончания поиска

    auto end = chrono::high_resolution_clock::now(); // Запоминаем момент времени окончания алгоритма

    // Вычисление длительности выполнения

    chrono::duration<double, milli> duration = end - start; // Разница времени в миллисекундах

    // Вывод результатов

    cout << "--- Search Results (Sequentially) ---" << endl;
    cout << "Size of the array: " << N << endl;                  // Выводим размер массива
    cout << "Minimum element: " << min_val << endl;     // Выводим найденный минимум
    cout << "Maximum element: " << max_val << endl;    // Выводим найденный максимум
    cout << "Lead time: " << duration.count() << " ms" << endl; // Время выполнения в миллисекундах

    // Освобождение памяти
    
    delete[] arr; // Освобождаем память, выделенную через new[]
    arr = nullptr; // Обнуляем указатель (хорошая практика)

    return 0;      // Возвращаем 0 
}
